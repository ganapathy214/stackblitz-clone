"use strict";
exports.id = 320;
exports.ids = [320];
exports.modules = {

/***/ 2320:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ es_Typography)
});

// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(6689);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(7462);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/CheckOutlined.js
// This icon file is generated automatically.
var CheckOutlined = {
    "icon": {
        "tag": "svg",
        "attrs": {
            "viewBox": "64 64 896 896",
            "focusable": "false"
        },
        "children": [
            {
                "tag": "path",
                "attrs": {
                    "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z"
                }
            }
        ]
    },
    "name": "check",
    "theme": "outlined"
};
/* harmony default export */ const asn_CheckOutlined = (CheckOutlined);

// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/components/AntdIcon.js + 10 modules
var AntdIcon = __webpack_require__(1804);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/CheckOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY



var CheckOutlined_CheckOutlined = function CheckOutlined(props, ref) {
    return /*#__PURE__*/ external_react_.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
        ref: ref,
        icon: asn_CheckOutlined
    }));
};
if (false) {}
/* harmony default export */ const icons_CheckOutlined = (/*#__PURE__*/external_react_.forwardRef(CheckOutlined_CheckOutlined));

;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/CopyOutlined.js
// This icon file is generated automatically.
var CopyOutlined = {
    "icon": {
        "tag": "svg",
        "attrs": {
            "viewBox": "64 64 896 896",
            "focusable": "false"
        },
        "children": [
            {
                "tag": "path",
                "attrs": {
                    "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z"
                }
            }
        ]
    },
    "name": "copy",
    "theme": "outlined"
};
/* harmony default export */ const asn_CopyOutlined = (CopyOutlined);

;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/CopyOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY



var CopyOutlined_CopyOutlined = function CopyOutlined(props, ref) {
    return /*#__PURE__*/ external_react_.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
        ref: ref,
        icon: asn_CopyOutlined
    }));
};
if (false) {}
/* harmony default export */ const icons_CopyOutlined = (/*#__PURE__*/external_react_.forwardRef(CopyOutlined_CopyOutlined));

;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/EditOutlined.js
// This icon file is generated automatically.
var EditOutlined = {
    "icon": {
        "tag": "svg",
        "attrs": {
            "viewBox": "64 64 896 896",
            "focusable": "false"
        },
        "children": [
            {
                "tag": "path",
                "attrs": {
                    "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z"
                }
            }
        ]
    },
    "name": "edit",
    "theme": "outlined"
};
/* harmony default export */ const asn_EditOutlined = (EditOutlined);

;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/EditOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY



var EditOutlined_EditOutlined = function EditOutlined(props, ref) {
    return /*#__PURE__*/ external_react_.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
        ref: ref,
        icon: asn_EditOutlined
    }));
};
if (false) {}
/* harmony default export */ const icons_EditOutlined = (/*#__PURE__*/external_react_.forwardRef(EditOutlined_EditOutlined));

// EXTERNAL MODULE: external "classnames"
var external_classnames_ = __webpack_require__(9003);
var external_classnames_default = /*#__PURE__*/__webpack_require__.n(external_classnames_);
// EXTERNAL MODULE: external "copy-to-clipboard"
var external_copy_to_clipboard_ = __webpack_require__(8887);
var external_copy_to_clipboard_default = /*#__PURE__*/__webpack_require__.n(external_copy_to_clipboard_);
// EXTERNAL MODULE: external "rc-resize-observer"
var external_rc_resize_observer_ = __webpack_require__(1493);
var external_rc_resize_observer_default = /*#__PURE__*/__webpack_require__.n(external_rc_resize_observer_);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Children/toArray.js
var toArray = __webpack_require__(7438);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useLayoutEffect.js
var useLayoutEffect = __webpack_require__(8749);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useMergedState.js + 1 modules
var useMergedState = __webpack_require__(1436);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(8489);
// EXTERNAL MODULE: ./node_modules/rc-util/es/ref.js + 1 modules
var es_ref = __webpack_require__(7356);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Dom/canUseDom.js
var canUseDom = __webpack_require__(8930);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/styleChecker.js

var isStyleNameSupport = function isStyleNameSupport(styleName) {
    if ((0,canUseDom/* default */.Z)() && window.document.documentElement) {
        var styleNameList = Array.isArray(styleName) ? styleName : [
            styleName
        ];
        var documentElement = window.document.documentElement;
        return styleNameList.some(function(name) {
            return name in documentElement.style;
        });
    }
    return false;
};
var isStyleValueSupport = function isStyleValueSupport(styleName, value) {
    if (!isStyleNameSupport(styleName)) {
        return false;
    }
    var ele = document.createElement("div");
    var origin = ele.style[styleName];
    ele.style[styleName] = value;
    return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
    if (!Array.isArray(styleName) && styleValue !== undefined) {
        return isStyleValueSupport(styleName, styleValue);
    }
    return isStyleNameSupport(styleName);
}

;// CONCATENATED MODULE: ./node_modules/rc-util/es/KeyCode.js
/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */ var KeyCode = {
    /**
   * MAC_ENTER
   */ MAC_ENTER: 3,
    /**
   * BACKSPACE
   */ BACKSPACE: 8,
    /**
   * TAB
   */ TAB: 9,
    /**
   * NUMLOCK on FF/Safari Mac
   */ NUM_CENTER: 12,
    // NUMLOCK on FF/Safari Mac
    /**
   * ENTER
   */ ENTER: 13,
    /**
   * SHIFT
   */ SHIFT: 16,
    /**
   * CTRL
   */ CTRL: 17,
    /**
   * ALT
   */ ALT: 18,
    /**
   * PAUSE
   */ PAUSE: 19,
    /**
   * CAPS_LOCK
   */ CAPS_LOCK: 20,
    /**
   * ESC
   */ ESC: 27,
    /**
   * SPACE
   */ SPACE: 32,
    /**
   * PAGE_UP
   */ PAGE_UP: 33,
    // also NUM_NORTH_EAST
    /**
   * PAGE_DOWN
   */ PAGE_DOWN: 34,
    // also NUM_SOUTH_EAST
    /**
   * END
   */ END: 35,
    // also NUM_SOUTH_WEST
    /**
   * HOME
   */ HOME: 36,
    // also NUM_NORTH_WEST
    /**
   * LEFT
   */ LEFT: 37,
    // also NUM_WEST
    /**
   * UP
   */ UP: 38,
    // also NUM_NORTH
    /**
   * RIGHT
   */ RIGHT: 39,
    // also NUM_EAST
    /**
   * DOWN
   */ DOWN: 40,
    // also NUM_SOUTH
    /**
   * PRINT_SCREEN
   */ PRINT_SCREEN: 44,
    /**
   * INSERT
   */ INSERT: 45,
    // also NUM_INSERT
    /**
   * DELETE
   */ DELETE: 46,
    // also NUM_DELETE
    /**
   * ZERO
   */ ZERO: 48,
    /**
   * ONE
   */ ONE: 49,
    /**
   * TWO
   */ TWO: 50,
    /**
   * THREE
   */ THREE: 51,
    /**
   * FOUR
   */ FOUR: 52,
    /**
   * FIVE
   */ FIVE: 53,
    /**
   * SIX
   */ SIX: 54,
    /**
   * SEVEN
   */ SEVEN: 55,
    /**
   * EIGHT
   */ EIGHT: 56,
    /**
   * NINE
   */ NINE: 57,
    /**
   * QUESTION_MARK
   */ QUESTION_MARK: 63,
    // needs localization
    /**
   * A
   */ A: 65,
    /**
   * B
   */ B: 66,
    /**
   * C
   */ C: 67,
    /**
   * D
   */ D: 68,
    /**
   * E
   */ E: 69,
    /**
   * F
   */ F: 70,
    /**
   * G
   */ G: 71,
    /**
   * H
   */ H: 72,
    /**
   * I
   */ I: 73,
    /**
   * J
   */ J: 74,
    /**
   * K
   */ K: 75,
    /**
   * L
   */ L: 76,
    /**
   * M
   */ M: 77,
    /**
   * N
   */ N: 78,
    /**
   * O
   */ O: 79,
    /**
   * P
   */ P: 80,
    /**
   * Q
   */ Q: 81,
    /**
   * R
   */ R: 82,
    /**
   * S
   */ S: 83,
    /**
   * T
   */ T: 84,
    /**
   * U
   */ U: 85,
    /**
   * V
   */ V: 86,
    /**
   * W
   */ W: 87,
    /**
   * X
   */ X: 88,
    /**
   * Y
   */ Y: 89,
    /**
   * Z
   */ Z: 90,
    /**
   * META
   */ META: 91,
    // WIN_KEY_LEFT
    /**
   * WIN_KEY_RIGHT
   */ WIN_KEY_RIGHT: 92,
    /**
   * CONTEXT_MENU
   */ CONTEXT_MENU: 93,
    /**
   * NUM_ZERO
   */ NUM_ZERO: 96,
    /**
   * NUM_ONE
   */ NUM_ONE: 97,
    /**
   * NUM_TWO
   */ NUM_TWO: 98,
    /**
   * NUM_THREE
   */ NUM_THREE: 99,
    /**
   * NUM_FOUR
   */ NUM_FOUR: 100,
    /**
   * NUM_FIVE
   */ NUM_FIVE: 101,
    /**
   * NUM_SIX
   */ NUM_SIX: 102,
    /**
   * NUM_SEVEN
   */ NUM_SEVEN: 103,
    /**
   * NUM_EIGHT
   */ NUM_EIGHT: 104,
    /**
   * NUM_NINE
   */ NUM_NINE: 105,
    /**
   * NUM_MULTIPLY
   */ NUM_MULTIPLY: 106,
    /**
   * NUM_PLUS
   */ NUM_PLUS: 107,
    /**
   * NUM_MINUS
   */ NUM_MINUS: 109,
    /**
   * NUM_PERIOD
   */ NUM_PERIOD: 110,
    /**
   * NUM_DIVISION
   */ NUM_DIVISION: 111,
    /**
   * F1
   */ F1: 112,
    /**
   * F2
   */ F2: 113,
    /**
   * F3
   */ F3: 114,
    /**
   * F4
   */ F4: 115,
    /**
   * F5
   */ F5: 116,
    /**
   * F6
   */ F6: 117,
    /**
   * F7
   */ F7: 118,
    /**
   * F8
   */ F8: 119,
    /**
   * F9
   */ F9: 120,
    /**
   * F10
   */ F10: 121,
    /**
   * F11
   */ F11: 122,
    /**
   * F12
   */ F12: 123,
    /**
   * NUMLOCK
   */ NUMLOCK: 144,
    /**
   * SEMICOLON
   */ SEMICOLON: 186,
    // needs localization
    /**
   * DASH
   */ DASH: 189,
    // needs localization
    /**
   * EQUALS
   */ EQUALS: 187,
    // needs localization
    /**
   * COMMA
   */ COMMA: 188,
    // needs localization
    /**
   * PERIOD
   */ PERIOD: 190,
    // needs localization
    /**
   * SLASH
   */ SLASH: 191,
    // needs localization
    /**
   * APOSTROPHE
   */ APOSTROPHE: 192,
    // needs localization
    /**
   * SINGLE_QUOTE
   */ SINGLE_QUOTE: 222,
    // needs localization
    /**
   * OPEN_SQUARE_BRACKET
   */ OPEN_SQUARE_BRACKET: 219,
    // needs localization
    /**
   * BACKSLASH
   */ BACKSLASH: 220,
    // needs localization
    /**
   * CLOSE_SQUARE_BRACKET
   */ CLOSE_SQUARE_BRACKET: 221,
    // needs localization
    /**
   * WIN_KEY
   */ WIN_KEY: 224,
    /**
   * MAC_FF_META
   */ MAC_FF_META: 224,
    // Firefox (Gecko) fires this for the meta key instead of 91
    /**
   * WIN_IME
   */ WIN_IME: 229,
    // ======================== Function ========================
    /**
   * whether text and modified key is entered at the same time.
   */ isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
        var keyCode = e.keyCode;
        if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
        keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
            return false;
        }
        // The following keys are quite harmless, even in combination with
        // CTRL, ALT or SHIFT.
        switch(keyCode){
            case KeyCode.ALT:
            case KeyCode.CAPS_LOCK:
            case KeyCode.CONTEXT_MENU:
            case KeyCode.CTRL:
            case KeyCode.DOWN:
            case KeyCode.END:
            case KeyCode.ESC:
            case KeyCode.HOME:
            case KeyCode.INSERT:
            case KeyCode.LEFT:
            case KeyCode.MAC_FF_META:
            case KeyCode.META:
            case KeyCode.NUMLOCK:
            case KeyCode.NUM_CENTER:
            case KeyCode.PAGE_DOWN:
            case KeyCode.PAGE_UP:
            case KeyCode.PAUSE:
            case KeyCode.PRINT_SCREEN:
            case KeyCode.RIGHT:
            case KeyCode.SHIFT:
            case KeyCode.UP:
            case KeyCode.WIN_KEY:
            case KeyCode.WIN_KEY_RIGHT:
                return false;
            default:
                return true;
        }
    },
    /**
   * whether character is entered.
   */ isCharacterKey: function isCharacterKey(keyCode) {
        if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
            return true;
        }
        if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
            return true;
        }
        if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
            return true;
        }
        // Safari sends zero key code for non-latin characters.
        if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
            return true;
        }
        switch(keyCode){
            case KeyCode.SPACE:
            case KeyCode.QUESTION_MARK:
            case KeyCode.NUM_PLUS:
            case KeyCode.NUM_MINUS:
            case KeyCode.NUM_PERIOD:
            case KeyCode.NUM_DIVISION:
            case KeyCode.SEMICOLON:
            case KeyCode.DASH:
            case KeyCode.EQUALS:
            case KeyCode.COMMA:
            case KeyCode.PERIOD:
            case KeyCode.SLASH:
            case KeyCode.APOSTROPHE:
            case KeyCode.SINGLE_QUOTE:
            case KeyCode.OPEN_SQUARE_BRACKET:
            case KeyCode.BACKSLASH:
            case KeyCode.CLOSE_SQUARE_BRACKET:
                return true;
            default:
                return false;
        }
    }
};
/* harmony default export */ const es_KeyCode = (KeyCode);

;// CONCATENATED MODULE: ./node_modules/antd/es/_util/transButton.js
var __rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
/**
 * Wrap of sub component which need use as Button capacity (like Icon component).
 *
 * This helps accessibility reader to tread as a interactive button to operation.
 */ 

const inlineStyle = {
    border: 0,
    background: "transparent",
    padding: 0,
    lineHeight: "inherit",
    display: "inline-block"
};
const TransButton = /*#__PURE__*/ external_react_.forwardRef((props, ref)=>{
    const onKeyDown = (event)=>{
        const { keyCode } = event;
        if (keyCode === es_KeyCode.ENTER) {
            event.preventDefault();
        }
    };
    const onKeyUp = (event)=>{
        const { keyCode } = event;
        const { onClick } = props;
        if (keyCode === es_KeyCode.ENTER && onClick) {
            onClick();
        }
    };
    const { style, noStyle, disabled } = props, restProps = __rest(props, [
        "style",
        "noStyle",
        "disabled"
    ]);
    let mergedStyle = {};
    if (!noStyle) {
        mergedStyle = Object.assign({}, inlineStyle);
    }
    if (disabled) {
        mergedStyle.pointerEvents = "none";
    }
    mergedStyle = Object.assign(Object.assign({}, mergedStyle), style);
    return /*#__PURE__*/ external_react_.createElement("div", Object.assign({
        role: "button",
        tabIndex: 0,
        ref: ref
    }, restProps, {
        onKeyDown: onKeyDown,
        onKeyUp: onKeyUp,
        style: mergedStyle
    }));
});
/* harmony default export */ const transButton = (TransButton);

// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(1864);
;// CONCATENATED MODULE: ./node_modules/antd/es/locale/context.js

const LocaleContext = /*#__PURE__*/ (0,external_react_.createContext)(undefined);
/* harmony default export */ const locale_context = (LocaleContext);

;// CONCATENATED MODULE: ./node_modules/rc-pagination/es/locale/en_US.js
/* harmony default export */ const en_US = ({
    // Options.jsx
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "Page",
    // Pagination.jsx
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages",
    page_size: "Page Size"
});

;// CONCATENATED MODULE: ./node_modules/rc-picker/es/locale/en_US.js
var locale = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "OK",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: true,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
};
/* harmony default export */ const locale_en_US = (locale);

;// CONCATENATED MODULE: ./node_modules/antd/es/time-picker/locale/en_US.js
const en_US_locale = {
    placeholder: "Select time",
    rangePlaceholder: [
        "Start time",
        "End time"
    ]
};
/* harmony default export */ const time_picker_locale_en_US = (en_US_locale);

;// CONCATENATED MODULE: ./node_modules/antd/es/date-picker/locale/en_US.js


// Merge into a locale object
const locale_en_US_locale = {
    lang: Object.assign({
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: [
            "Start date",
            "End date"
        ],
        rangeYearPlaceholder: [
            "Start year",
            "End year"
        ],
        rangeQuarterPlaceholder: [
            "Start quarter",
            "End quarter"
        ],
        rangeMonthPlaceholder: [
            "Start month",
            "End month"
        ],
        rangeWeekPlaceholder: [
            "Start week",
            "End week"
        ]
    }, locale_en_US),
    timePickerLocale: Object.assign({}, time_picker_locale_en_US)
};
// All settings at:
// https://github.com/ant-design/ant-design/blob/master/components/date-picker/locale/example.json
/* harmony default export */ const date_picker_locale_en_US = (locale_en_US_locale);

;// CONCATENATED MODULE: ./node_modules/antd/es/calendar/locale/en_US.js

/* harmony default export */ const calendar_locale_en_US = (date_picker_locale_en_US);

;// CONCATENATED MODULE: ./node_modules/antd/es/locale/en_US.js
/* eslint-disable no-template-curly-in-string */ 



const typeTemplate = "${label} is not a valid ${type}";
const localeValues = {
    locale: "en",
    Pagination: en_US,
    DatePicker: date_picker_locale_en_US,
    TimePicker: time_picker_locale_en_US,
    Calendar: calendar_locale_en_US,
    global: {
        placeholder: "Please select"
    },
    Table: {
        filterTitle: "Filter menu",
        filterConfirm: "OK",
        filterReset: "Reset",
        filterEmptyText: "No filters",
        filterCheckall: "Select all items",
        filterSearchPlaceholder: "Search in filters",
        emptyText: "No data",
        selectAll: "Select current page",
        selectInvert: "Invert current page",
        selectNone: "Clear all data",
        selectionAll: "Select all data",
        sortTitle: "Sort",
        expand: "Expand row",
        collapse: "Collapse row",
        triggerDesc: "Click to sort descending",
        triggerAsc: "Click to sort ascending",
        cancelSort: "Click to cancel sorting"
    },
    Tour: {
        Next: "Next",
        Previous: "Previous",
        Finish: "Finish"
    },
    Modal: {
        okText: "OK",
        cancelText: "Cancel",
        justOkText: "OK"
    },
    Popconfirm: {
        okText: "OK",
        cancelText: "Cancel"
    },
    Transfer: {
        titles: [
            "",
            ""
        ],
        searchPlaceholder: "Search here",
        itemUnit: "item",
        itemsUnit: "items",
        remove: "Remove",
        selectCurrent: "Select current page",
        removeCurrent: "Remove current page",
        selectAll: "Select all data",
        removeAll: "Remove all data",
        selectInvert: "Invert current page"
    },
    Upload: {
        uploading: "Uploading...",
        removeFile: "Remove file",
        uploadError: "Upload error",
        previewFile: "Preview file",
        downloadFile: "Download file"
    },
    Empty: {
        description: "No data"
    },
    Icon: {
        icon: "icon"
    },
    Text: {
        edit: "Edit",
        copy: "Copy",
        copied: "Copied",
        expand: "Expand"
    },
    PageHeader: {
        back: "Back"
    },
    Form: {
        optional: "(optional)",
        defaultValidateMessages: {
            default: "Field validation error for ${label}",
            required: "Please enter ${label}",
            enum: "${label} must be one of [${enum}]",
            whitespace: "${label} cannot be a blank character",
            date: {
                format: "${label} date format is invalid",
                parse: "${label} cannot be converted to a date",
                invalid: "${label} is an invalid date"
            },
            types: {
                string: typeTemplate,
                method: typeTemplate,
                array: typeTemplate,
                object: typeTemplate,
                number: typeTemplate,
                date: typeTemplate,
                boolean: typeTemplate,
                integer: typeTemplate,
                float: typeTemplate,
                regexp: typeTemplate,
                email: typeTemplate,
                url: typeTemplate,
                hex: typeTemplate
            },
            string: {
                len: "${label} must be ${len} characters",
                min: "${label} must be at least ${min} characters",
                max: "${label} must be up to ${max} characters",
                range: "${label} must be between ${min}-${max} characters"
            },
            number: {
                len: "${label} must be equal to ${len}",
                min: "${label} must be minimum ${min}",
                max: "${label} must be maximum ${max}",
                range: "${label} must be between ${min}-${max}"
            },
            array: {
                len: "Must be ${len} ${label}",
                min: "At least ${min} ${label}",
                max: "At most ${max} ${label}",
                range: "The amount of ${label} must be between ${min}-${max}"
            },
            pattern: {
                mismatch: "${label} does not match the pattern ${pattern}"
            }
        }
    },
    Image: {
        preview: "Preview"
    },
    QRCode: {
        expired: "QR code expired",
        refresh: "Refresh"
    },
    ColorPicker: {
        presetEmpty: "Empty"
    }
};
/* harmony default export */ const es_locale_en_US = (localeValues);

;// CONCATENATED MODULE: ./node_modules/antd/es/locale/useLocale.js



const useLocale = (componentName, defaultLocale)=>{
    const fullLocale = external_react_.useContext(locale_context);
    const getLocale = external_react_.useMemo(()=>{
        var _a;
        const locale = defaultLocale || es_locale_en_US[componentName];
        const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
        return Object.assign(Object.assign({}, typeof locale === "function" ? locale() : locale), localeFromContext || {});
    }, [
        componentName,
        defaultLocale,
        fullLocale
    ]);
    const getLocaleCode = external_react_.useMemo(()=>{
        const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
        // Had use LocaleProvide but didn't set locale
        if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
            return es_locale_en_US.locale;
        }
        return localeCode;
    }, [
        fullLocale
    ]);
    return [
        getLocale,
        getLocaleCode
    ];
};
/* harmony default export */ const locale_useLocale = (useLocale);

// EXTERNAL MODULE: ./node_modules/antd/es/tooltip/index.js + 16 modules
var es_tooltip = __webpack_require__(2204);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/EnterOutlined.js
// This icon file is generated automatically.
var EnterOutlined = {
    "icon": {
        "tag": "svg",
        "attrs": {
            "viewBox": "64 64 896 896",
            "focusable": "false"
        },
        "children": [
            {
                "tag": "path",
                "attrs": {
                    "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z"
                }
            }
        ]
    },
    "name": "enter",
    "theme": "outlined"
};
/* harmony default export */ const asn_EnterOutlined = (EnterOutlined);

;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/EnterOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY



var EnterOutlined_EnterOutlined = function EnterOutlined(props, ref) {
    return /*#__PURE__*/ external_react_.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
        ref: ref,
        icon: asn_EnterOutlined
    }));
};
if (false) {}
/* harmony default export */ const icons_EnterOutlined = (/*#__PURE__*/external_react_.forwardRef(EnterOutlined_EnterOutlined));

;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/CloseCircleFilled.js
// This icon file is generated automatically.
var CloseCircleFilled_CloseCircleFilled = {
    "icon": {
        "tag": "svg",
        "attrs": {
            "viewBox": "64 64 896 896",
            "focusable": "false"
        },
        "children": [
            {
                "tag": "path",
                "attrs": {
                    "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z"
                }
            }
        ]
    },
    "name": "close-circle",
    "theme": "filled"
};
/* harmony default export */ const asn_CloseCircleFilled = (CloseCircleFilled_CloseCircleFilled);

;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/CloseCircleFilled.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY



var icons_CloseCircleFilled_CloseCircleFilled = function CloseCircleFilled(props, ref) {
    return /*#__PURE__*/ external_react_.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
        ref: ref,
        icon: asn_CloseCircleFilled
    }));
};
if (false) {}
/* harmony default export */ const icons_CloseCircleFilled = (/*#__PURE__*/external_react_.forwardRef(icons_CloseCircleFilled_CloseCircleFilled));

// EXTERNAL MODULE: external "rc-textarea"
var external_rc_textarea_ = __webpack_require__(8880);
var external_rc_textarea_default = /*#__PURE__*/__webpack_require__.n(external_rc_textarea_);
;// CONCATENATED MODULE: ./node_modules/antd/es/_util/statusUtils.js

const InputStatuses = (/* unused pure expression or super */ null && ([
    "warning",
    "error",
    ""
]));
function statusUtils_getStatusClassNames(prefixCls, status, hasFeedback) {
    return external_classnames_default()({
        [`${prefixCls}-status-success`]: status === "success",
        [`${prefixCls}-status-warning`]: status === "warning",
        [`${prefixCls}-status-error`]: status === "error",
        [`${prefixCls}-status-validating`]: status === "validating",
        [`${prefixCls}-has-feedback`]: hasFeedback
    });
}
const statusUtils_getMergedStatus = (contextStatus, customStatus)=>customStatus || contextStatus;

// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/DisabledContext.js
var config_provider_DisabledContext = __webpack_require__(9234);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useSize.js + 1 modules
var hooks_useSize = __webpack_require__(705);
// EXTERNAL MODULE: ./node_modules/antd/es/form/context.js
var form_context = __webpack_require__(9319);
// EXTERNAL MODULE: external "rc-input"
var external_rc_input_ = __webpack_require__(4326);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/Input.js
var Input_rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};















function triggerFocus(element, option) {
    if (!element) {
        return;
    }
    element.focus(option);
    // Selection content
    const { cursor } = option || {};
    if (cursor) {
        const len = element.value.length;
        switch(cursor){
            case "start":
                element.setSelectionRange(0, 0);
                break;
            case "end":
                element.setSelectionRange(len, len);
                break;
            default:
                element.setSelectionRange(0, len);
                break;
        }
    }
}
const Input = /*#__PURE__*/ (/* unused pure expression or super */ null && (forwardRef((props, ref)=>{
    const { prefixCls: customizePrefixCls, bordered = true, status: customStatus, size: customSize, disabled: customDisabled, onBlur, onFocus, suffix, allowClear, addonAfter, addonBefore, className, rootClassName, onChange, classNames: classes } = props, rest = Input_rest(props, [
        "prefixCls",
        "bordered",
        "status",
        "size",
        "disabled",
        "onBlur",
        "onFocus",
        "suffix",
        "allowClear",
        "addonAfter",
        "addonBefore",
        "className",
        "rootClassName",
        "onChange",
        "classNames"
    ]);
    const { getPrefixCls, direction, input } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls("input", customizePrefixCls);
    const inputRef = useRef(null);
    // Style
    const [wrapSSR, hashId] = useStyle(prefixCls);
    // ===================== Compact Item =====================
    const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
    // ===================== Size =====================
    const mergedSize = useSize((ctx)=>{
        var _a;
        return (_a = customSize !== null && customSize !== void 0 ? customSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
    });
    // ===================== Disabled =====================
    const disabled = React.useContext(DisabledContext);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    // ===================== Status =====================
    const { status: contextStatus, hasFeedback, feedbackIcon } = useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    // ===================== Focus warning =====================
    const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
    const prevHasPrefixSuffix = useRef(inputHasPrefixSuffix);
    useEffect(()=>{
        var _a;
        if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current) {
             false ? 0 : void 0;
        }
        prevHasPrefixSuffix.current = inputHasPrefixSuffix;
    }, [
        inputHasPrefixSuffix
    ]);
    // ===================== Remove Password value =====================
    const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
    const handleBlur = (e)=>{
        removePasswordTimeout();
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    };
    const handleFocus = (e)=>{
        removePasswordTimeout();
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
    };
    const handleChange = (e)=>{
        removePasswordTimeout();
        onChange === null || onChange === void 0 ? void 0 : onChange(e);
    };
    const suffixNode = (hasFeedback || suffix) && /*#__PURE__*/ React.createElement(React.Fragment, null, suffix, hasFeedback && feedbackIcon);
    // Allow clear
    let mergedAllowClear;
    if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
        mergedAllowClear = allowClear;
    } else if (allowClear) {
        mergedAllowClear = {
            clearIcon: /*#__PURE__*/ React.createElement(CloseCircleFilled, null)
        };
    }
    return wrapSSR(/*#__PURE__*/ React.createElement(RcInput, Object.assign({
        ref: composeRef(ref, inputRef),
        prefixCls: prefixCls,
        autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete
    }, rest, {
        disabled: mergedDisabled,
        onBlur: handleBlur,
        onFocus: handleFocus,
        suffix: suffixNode,
        allowClear: mergedAllowClear,
        className: classNames(className, rootClassName, compactItemClassnames),
        onChange: handleChange,
        addonAfter: addonAfter && /*#__PURE__*/ React.createElement(NoCompactStyle, null, /*#__PURE__*/ React.createElement(NoFormStyle, {
            override: true,
            status: true
        }, addonAfter)),
        addonBefore: addonBefore && /*#__PURE__*/ React.createElement(NoCompactStyle, null, /*#__PURE__*/ React.createElement(NoFormStyle, {
            override: true,
            status: true
        }, addonBefore)),
        classNames: Object.assign(Object.assign({}, classes), {
            input: classNames({
                [`${prefixCls}-sm`]: mergedSize === "small",
                [`${prefixCls}-lg`]: mergedSize === "large",
                [`${prefixCls}-rtl`]: direction === "rtl",
                [`${prefixCls}-borderless`]: !bordered
            }, !inputHasPrefixSuffix && getStatusClassNames(prefixCls, mergedStatus), classes === null || classes === void 0 ? void 0 : classes.input, hashId)
        }),
        classes: {
            affixWrapper: classNames({
                [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
                [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
                [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
                [`${prefixCls}-affix-wrapper-borderless`]: !bordered
            }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus, hasFeedback), hashId),
            wrapper: classNames({
                [`${prefixCls}-group-rtl`]: direction === "rtl"
            }, hashId),
            group: classNames({
                [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
                [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
                [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
                [`${prefixCls}-group-wrapper-disabled`]: mergedDisabled
            }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
        }
    })));
})));
/* harmony default export */ const input_Input = ((/* unused pure expression or super */ null && (Input)));

// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js
var style = __webpack_require__(9902);
// EXTERNAL MODULE: ./node_modules/antd/es/style/compact-item.js
var compact_item = __webpack_require__(5432);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(8604);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js
var genComponentStyleHook = __webpack_require__(5472);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/style/index.js



const genPlaceholderStyle = (color)=>({
        // Firefox
        "&::-moz-placeholder": {
            opacity: 1
        },
        "&::placeholder": {
            color,
            userSelect: "none" // https://github.com/ant-design/ant-design/pull/32639
        },
        "&:placeholder-shown": {
            textOverflow: "ellipsis"
        }
    });
const genHoverStyle = (token)=>({
        borderColor: token.inputBorderHoverColor,
        borderInlineEndWidth: token.lineWidth
    });
const genActiveStyle = (token)=>({
        borderColor: token.inputBorderHoverColor,
        boxShadow: `0 0 0 ${token.controlOutlineWidth}px ${token.controlOutline}`,
        borderInlineEndWidth: token.lineWidth,
        outline: 0
    });
const genDisabledStyle = (token)=>({
        color: token.colorTextDisabled,
        backgroundColor: token.colorBgContainerDisabled,
        borderColor: token.colorBorder,
        boxShadow: "none",
        cursor: "not-allowed",
        opacity: 1,
        "&:hover": Object.assign({}, genHoverStyle((0,statistic/* merge */.TS)(token, {
            inputBorderHoverColor: token.colorBorder
        })))
    });
const genInputLargeStyle = (token)=>{
    const { inputPaddingVerticalLG, fontSizeLG, lineHeightLG, borderRadiusLG, inputPaddingHorizontalLG } = token;
    return {
        padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderRadius: borderRadiusLG
    };
};
const genInputSmallStyle = (token)=>({
        padding: `${token.inputPaddingVerticalSM}px ${token.controlPaddingHorizontalSM - 1}px`,
        borderRadius: token.borderRadiusSM
    });
const genStatusStyle = (token, parentCls)=>{
    const { componentCls, colorError, colorWarning, colorErrorOutline, colorWarningOutline, colorErrorBorderHover, colorWarningBorderHover } = token;
    return {
        [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
            borderColor: colorError,
            "&:hover": {
                borderColor: colorErrorBorderHover
            },
            "&:focus, &-focused": Object.assign({}, genActiveStyle((0,statistic/* merge */.TS)(token, {
                inputBorderActiveColor: colorError,
                inputBorderHoverColor: colorError,
                controlOutline: colorErrorOutline
            }))),
            [`${componentCls}-prefix, ${componentCls}-suffix`]: {
                color: colorError
            }
        },
        [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
            borderColor: colorWarning,
            "&:hover": {
                borderColor: colorWarningBorderHover
            },
            "&:focus, &-focused": Object.assign({}, genActiveStyle((0,statistic/* merge */.TS)(token, {
                inputBorderActiveColor: colorWarning,
                inputBorderHoverColor: colorWarning,
                controlOutline: colorWarningOutline
            }))),
            [`${componentCls}-prefix, ${componentCls}-suffix`]: {
                color: colorWarning
            }
        }
    };
};
const genBasicInputStyle = (token)=>Object.assign(Object.assign({
        position: "relative",
        display: "inline-block",
        width: "100%",
        minWidth: 0,
        padding: `${token.inputPaddingVertical}px ${token.inputPaddingHorizontal}px`,
        color: token.colorText,
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        backgroundColor: token.colorBgContainer,
        backgroundImage: "none",
        borderWidth: token.lineWidth,
        borderStyle: token.lineType,
        borderColor: token.colorBorder,
        borderRadius: token.borderRadius,
        transition: `all ${token.motionDurationMid}`
    }, genPlaceholderStyle(token.colorTextPlaceholder)), {
        "&:hover": Object.assign({}, genHoverStyle(token)),
        "&:focus, &-focused": Object.assign({}, genActiveStyle(token)),
        "&-disabled, &[disabled]": Object.assign({}, genDisabledStyle(token)),
        "&-borderless": {
            "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
                backgroundColor: "transparent",
                border: "none",
                boxShadow: "none"
            }
        },
        // Reset height for `textarea`s
        "textarea&": {
            maxWidth: "100%",
            height: "auto",
            minHeight: token.controlHeight,
            lineHeight: token.lineHeight,
            verticalAlign: "bottom",
            transition: `all ${token.motionDurationSlow}, height 0s`,
            resize: "vertical"
        },
        // Size
        "&-lg": Object.assign({}, genInputLargeStyle(token)),
        "&-sm": Object.assign({}, genInputSmallStyle(token)),
        // RTL
        "&-rtl": {
            direction: "rtl"
        },
        "&-textarea-rtl": {
            direction: "rtl"
        }
    });
const genInputGroupStyle = (token)=>{
    const { componentCls, antCls } = token;
    return {
        position: "relative",
        display: "table",
        width: "100%",
        borderCollapse: "separate",
        borderSpacing: 0,
        // Undo padding and float of grid classes
        [`&[class*='col-']`]: {
            paddingInlineEnd: token.paddingXS,
            "&:last-child": {
                paddingInlineEnd: 0
            }
        },
        // Sizing options
        [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token)),
        [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token)),
        // Fix https://github.com/ant-design/ant-design/issues/5754
        [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
            height: token.controlHeightLG
        },
        [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
            height: token.controlHeightSM
        },
        [`> ${componentCls}`]: {
            display: "table-cell",
            "&:not(:first-child):not(:last-child)": {
                borderRadius: 0
            }
        },
        [`${componentCls}-group`]: {
            [`&-addon, &-wrap`]: {
                display: "table-cell",
                width: 1,
                whiteSpace: "nowrap",
                verticalAlign: "middle",
                "&:not(:first-child):not(:last-child)": {
                    borderRadius: 0
                }
            },
            "&-wrap > *": {
                display: "block !important"
            },
            "&-addon": {
                position: "relative",
                padding: `0 ${token.inputPaddingHorizontal}px`,
                color: token.colorText,
                fontWeight: "normal",
                fontSize: token.fontSize,
                textAlign: "center",
                backgroundColor: token.colorFillAlter,
                border: `${token.lineWidth}px ${token.lineType} ${token.colorBorder}`,
                borderRadius: token.borderRadius,
                transition: `all ${token.motionDurationSlow}`,
                lineHeight: 1,
                // Reset Select's style in addon
                [`${antCls}-select`]: {
                    margin: `-${token.inputPaddingVertical + 1}px -${token.inputPaddingHorizontal}px`,
                    [`&${antCls}-select-single:not(${antCls}-select-customize-input)`]: {
                        [`${antCls}-select-selector`]: {
                            backgroundColor: "inherit",
                            border: `${token.lineWidth}px ${token.lineType} transparent`,
                            boxShadow: "none"
                        }
                    },
                    "&-open, &-focused": {
                        [`${antCls}-select-selector`]: {
                            color: token.colorPrimary
                        }
                    }
                },
                // https://github.com/ant-design/ant-design/issues/31333
                [`${antCls}-cascader-picker`]: {
                    margin: `-9px -${token.inputPaddingHorizontal}px`,
                    backgroundColor: "transparent",
                    [`${antCls}-cascader-input`]: {
                        textAlign: "start",
                        border: 0,
                        boxShadow: "none"
                    }
                }
            },
            "&-addon:first-child": {
                borderInlineEnd: 0
            },
            "&-addon:last-child": {
                borderInlineStart: 0
            }
        },
        [`${componentCls}`]: {
            width: "100%",
            marginBottom: 0,
            textAlign: "inherit",
            "&:focus": {
                zIndex: 1,
                borderInlineEndWidth: 1
            },
            "&:hover": {
                zIndex: 1,
                borderInlineEndWidth: 1,
                [`${componentCls}-search-with-button &`]: {
                    zIndex: 0
                }
            }
        },
        // Reset rounded corners
        [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            // Reset Select's style in addon
            [`${antCls}-select ${antCls}-select-selector`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
            }
        },
        [`> ${componentCls}-affix-wrapper`]: {
            [`&:not(:first-child) ${componentCls}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
            },
            [`&:not(:last-child) ${componentCls}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
            }
        },
        [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0,
            // Reset Select's style in addon
            [`${antCls}-select ${antCls}-select-selector`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
            }
        },
        [`${componentCls}-affix-wrapper`]: {
            "&:not(:last-child)": {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                [`${componentCls}-search &`]: {
                    borderStartStartRadius: token.borderRadius,
                    borderEndStartRadius: token.borderRadius
                }
            },
            [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
            }
        },
        [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
            display: "block"
        }, (0,style/* clearFix */.dF)()), {
            [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
                "&:not(:first-child):not(:last-child)": {
                    borderInlineEndWidth: token.lineWidth,
                    "&:hover": {
                        zIndex: 1
                    },
                    "&:focus": {
                        zIndex: 1
                    }
                }
            },
            "& > *": {
                display: "inline-block",
                float: "none",
                verticalAlign: "top",
                borderRadius: 0
            },
            [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
                display: "inline-flex"
            },
            "& > *:not(:last-child)": {
                marginInlineEnd: -token.lineWidth,
                borderInlineEndWidth: token.lineWidth
            },
            // Undo float for .ant-input-group .ant-input
            [`${componentCls}`]: {
                float: "none"
            },
            // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
            [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
                borderInlineEndWidth: token.lineWidth,
                borderRadius: 0,
                "&:hover": {
                    zIndex: 1
                },
                "&:focus": {
                    zIndex: 1
                }
            },
            [`& > ${antCls}-select-focused`]: {
                zIndex: 1
            },
            // update z-index for arrow icon
            [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
                zIndex: 1 // https://github.com/ant-design/ant-design/issues/20371
            },
            [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
                borderStartStartRadius: token.borderRadius,
                borderEndStartRadius: token.borderRadius
            },
            [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
                borderInlineEndWidth: token.lineWidth,
                borderStartEndRadius: token.borderRadius,
                borderEndEndRadius: token.borderRadius
            },
            // https://github.com/ant-design/ant-design/issues/12493
            [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
                verticalAlign: "top"
            },
            [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
                marginInlineStart: -token.lineWidth,
                [`${componentCls}-affix-wrapper`]: {
                    borderRadius: 0
                }
            },
            [`${componentCls}-group-wrapper:not(:last-child)`]: {
                [`&${componentCls}-search > ${componentCls}-group`]: {
                    [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
                        borderRadius: 0
                    },
                    [`& > ${componentCls}`]: {
                        borderStartStartRadius: token.borderRadius,
                        borderStartEndRadius: 0,
                        borderEndEndRadius: 0,
                        borderEndStartRadius: token.borderRadius
                    }
                }
            }
        })
    };
};
const genInputStyle = (token)=>{
    const { componentCls, controlHeightSM, lineWidth } = token;
    const FIXED_CHROME_COLOR_HEIGHT = 16;
    const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
    return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), genBasicInputStyle(token)), genStatusStyle(token, componentCls)), {
            '&[type="color"]': {
                height: token.controlHeight,
                [`&${componentCls}-lg`]: {
                    height: token.controlHeightLG
                },
                [`&${componentCls}-sm`]: {
                    height: controlHeightSM,
                    paddingTop: colorSmallPadding,
                    paddingBottom: colorSmallPadding
                }
            },
            '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
                "-webkit-appearance": "none"
            }
        })
    };
};
const genAllowClearStyle = (token)=>{
    const { componentCls } = token;
    return {
        // ========================= Input =========================
        [`${componentCls}-clear-icon`]: {
            margin: 0,
            color: token.colorTextQuaternary,
            fontSize: token.fontSizeIcon,
            verticalAlign: -1,
            // https://github.com/ant-design/ant-design/pull/18151
            // https://codesandbox.io/s/wizardly-sun-u10br
            cursor: "pointer",
            transition: `color ${token.motionDurationSlow}`,
            "&:hover": {
                color: token.colorTextTertiary
            },
            "&:active": {
                color: token.colorText
            },
            "&-hidden": {
                visibility: "hidden"
            },
            "&-has-suffix": {
                margin: `0 ${token.inputAffixPadding}px`
            }
        }
    };
};
const genAffixStyle = (token)=>{
    const { componentCls, inputAffixPadding, colorTextDescription, motionDurationSlow, colorIcon, colorIconHover, iconCls } = token;
    return {
        [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token)), {
            display: "inline-flex",
            [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: Object.assign(Object.assign({}, genHoverStyle(token)), {
                zIndex: 1,
                [`${componentCls}-search-with-button &`]: {
                    zIndex: 0
                }
            }),
            "&-focused, &:focus": {
                zIndex: 1
            },
            "&-disabled": {
                [`${componentCls}[disabled]`]: {
                    background: "transparent"
                }
            },
            [`> input${componentCls}`]: {
                padding: 0,
                fontSize: "inherit",
                border: "none",
                borderRadius: 0,
                outline: "none",
                "&::-ms-reveal": {
                    display: "none"
                },
                "&:focus": {
                    boxShadow: "none !important"
                }
            },
            "&::before": {
                display: "inline-block",
                width: 0,
                visibility: "hidden",
                content: '"\\a0"'
            },
            [`${componentCls}`]: {
                "&-prefix, &-suffix": {
                    display: "flex",
                    flex: "none",
                    alignItems: "center",
                    "> *:not(:last-child)": {
                        marginInlineEnd: token.paddingXS
                    }
                },
                "&-show-count-suffix": {
                    color: colorTextDescription
                },
                "&-show-count-has-suffix": {
                    marginInlineEnd: token.paddingXXS
                },
                "&-prefix": {
                    marginInlineEnd: inputAffixPadding
                },
                "&-suffix": {
                    marginInlineStart: inputAffixPadding
                }
            }
        }), genAllowClearStyle(token)), {
            // password
            [`${iconCls}${componentCls}-password-icon`]: {
                color: colorIcon,
                cursor: "pointer",
                transition: `all ${motionDurationSlow}`,
                "&:hover": {
                    color: colorIconHover
                }
            }
        }), genStatusStyle(token, `${componentCls}-affix-wrapper`))
    };
};
const genGroupStyle = (token)=>{
    const { componentCls, colorError, colorWarning, borderRadiusLG, borderRadiusSM } = token;
    return {
        [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), genInputGroupStyle(token)), {
            "&-rtl": {
                direction: "rtl"
            },
            "&-wrapper": {
                display: "inline-block",
                width: "100%",
                textAlign: "start",
                verticalAlign: "top",
                "&-rtl": {
                    direction: "rtl"
                },
                // Size
                "&-lg": {
                    [`${componentCls}-group-addon`]: {
                        borderRadius: borderRadiusLG
                    }
                },
                "&-sm": {
                    [`${componentCls}-group-addon`]: {
                        borderRadius: borderRadiusSM
                    }
                },
                // Status
                "&-status-error": {
                    [`${componentCls}-group-addon`]: {
                        color: colorError,
                        borderColor: colorError
                    }
                },
                "&-status-warning": {
                    [`${componentCls}-group-addon`]: {
                        color: colorWarning,
                        borderColor: colorWarning
                    }
                },
                "&-disabled": {
                    [`${componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token))
                },
                // Fix the issue of using icons in Space Compact mode
                // https://github.com/ant-design/ant-design/issues/42122
                [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
                    [`${componentCls}, ${componentCls}-group-addon`]: {
                        borderRadius: 0
                    }
                },
                [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
                    [`${componentCls}, ${componentCls}-group-addon`]: {
                        borderStartEndRadius: 0,
                        borderEndEndRadius: 0
                    }
                },
                [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
                    [`${componentCls}, ${componentCls}-group-addon`]: {
                        borderStartStartRadius: 0,
                        borderEndStartRadius: 0
                    }
                }
            }
        })
    };
};
const genSearchInputStyle = (token)=>{
    const { componentCls, antCls } = token;
    const searchPrefixCls = `${componentCls}-search`;
    return {
        [searchPrefixCls]: {
            [`${componentCls}`]: {
                "&:hover, &:focus": {
                    borderColor: token.colorPrimaryHover,
                    [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                        borderInlineStartColor: token.colorPrimaryHover
                    }
                }
            },
            [`${componentCls}-affix-wrapper`]: {
                borderRadius: 0
            },
            // fix slight height diff in Firefox:
            // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
            [`${componentCls}-lg`]: {
                lineHeight: token.lineHeightLG - 0.0002
            },
            [`> ${componentCls}-group`]: {
                [`> ${componentCls}-group-addon:last-child`]: {
                    insetInlineStart: -1,
                    padding: 0,
                    border: 0,
                    [`${searchPrefixCls}-button`]: {
                        paddingTop: 0,
                        paddingBottom: 0,
                        borderStartStartRadius: 0,
                        borderStartEndRadius: token.borderRadius,
                        borderEndEndRadius: token.borderRadius,
                        borderEndStartRadius: 0
                    },
                    [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                        color: token.colorTextDescription,
                        "&:hover": {
                            color: token.colorPrimaryHover
                        },
                        "&:active": {
                            color: token.colorPrimaryActive
                        },
                        [`&${antCls}-btn-loading::before`]: {
                            insetInlineStart: 0,
                            insetInlineEnd: 0,
                            insetBlockStart: 0,
                            insetBlockEnd: 0
                        }
                    }
                }
            },
            [`${searchPrefixCls}-button`]: {
                height: token.controlHeight,
                "&:hover, &:focus": {
                    zIndex: 1
                }
            },
            [`&-large ${searchPrefixCls}-button`]: {
                height: token.controlHeightLG
            },
            [`&-small ${searchPrefixCls}-button`]: {
                height: token.controlHeightSM
            },
            "&-rtl": {
                direction: "rtl"
            },
            // ===================== Compact Item Customized Styles =====================
            [`&${componentCls}-compact-item`]: {
                [`&:not(${componentCls}-compact-last-item)`]: {
                    [`${componentCls}-group-addon`]: {
                        [`${componentCls}-search-button`]: {
                            marginInlineEnd: -token.lineWidth,
                            borderRadius: 0
                        }
                    }
                },
                [`&:not(${componentCls}-compact-first-item)`]: {
                    [`${componentCls},${componentCls}-affix-wrapper`]: {
                        borderRadius: 0
                    }
                },
                [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
                    "&:hover,&:focus,&:active": {
                        zIndex: 2
                    }
                },
                [`> ${componentCls}-affix-wrapper-focused`]: {
                    zIndex: 2
                }
            }
        }
    };
};
function initInputToken(token) {
    // @ts-ignore
    return (0,statistic/* merge */.TS)(token, {
        inputAffixPadding: token.paddingXXS,
        inputPaddingVertical: Math.max(Math.round((token.controlHeight - token.fontSize * token.lineHeight) / 2 * 10) / 10 - token.lineWidth, 3),
        inputPaddingVerticalLG: Math.ceil((token.controlHeightLG - token.fontSizeLG * token.lineHeightLG) / 2 * 10) / 10 - token.lineWidth,
        inputPaddingVerticalSM: Math.max(Math.round((token.controlHeightSM - token.fontSize * token.lineHeight) / 2 * 10) / 10 - token.lineWidth, 0),
        inputPaddingHorizontal: token.paddingSM - token.lineWidth,
        inputPaddingHorizontalSM: token.paddingXS - token.lineWidth,
        inputPaddingHorizontalLG: token.controlPaddingHorizontal - token.lineWidth,
        inputBorderHoverColor: token.colorPrimaryHover,
        inputBorderActiveColor: token.colorPrimaryHover
    });
}
const genTextAreaStyle = (token)=>{
    const { componentCls, paddingLG } = token;
    const textareaPrefixCls = `${componentCls}-textarea`;
    return {
        [textareaPrefixCls]: {
            position: "relative",
            "&-show-count": {
                // https://github.com/ant-design/ant-design/issues/33049
                [`> ${componentCls}`]: {
                    height: "100%"
                },
                [`${componentCls}-data-count`]: {
                    position: "absolute",
                    bottom: -token.fontSize * token.lineHeight,
                    insetInlineEnd: 0,
                    color: token.colorTextDescription,
                    whiteSpace: "nowrap",
                    pointerEvents: "none"
                }
            },
            "&-allow-clear": {
                [`> ${componentCls}`]: {
                    paddingInlineEnd: paddingLG
                }
            },
            [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
                [`${componentCls}`]: {
                    paddingInlineEnd: paddingLG
                }
            },
            [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
                padding: 0,
                [`> textarea${componentCls}`]: {
                    fontSize: "inherit",
                    border: "none",
                    outline: "none",
                    "&:focus": {
                        boxShadow: "none !important"
                    }
                },
                [`${componentCls}-suffix`]: {
                    margin: 0,
                    "> *:not(:last-child)": {
                        marginInline: 0
                    },
                    // Clear Icon
                    [`${componentCls}-clear-icon`]: {
                        position: "absolute",
                        insetInlineEnd: token.paddingXS,
                        insetBlockStart: token.paddingXS
                    },
                    // Feedback Icon
                    [`${textareaPrefixCls}-suffix`]: {
                        position: "absolute",
                        top: 0,
                        insetInlineEnd: token.inputPaddingHorizontal,
                        bottom: 0,
                        zIndex: 1,
                        display: "inline-flex",
                        alignItems: "center",
                        margin: "auto",
                        pointerEvents: "none"
                    }
                }
            }
        }
    };
};
// ============================== Export ==============================
/* harmony default export */ const input_style = ((0,genComponentStyleHook/* default */.Z)("Input", (token)=>{
    const inputToken = initInputToken(token);
    return [
        genInputStyle(inputToken),
        genTextAreaStyle(inputToken),
        genAffixStyle(inputToken),
        genGroupStyle(inputToken),
        genSearchInputStyle(inputToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        (0,compact_item/* genCompactItemStyle */.c)(inputToken)
    ];
}));

;// CONCATENATED MODULE: ./node_modules/antd/es/input/TextArea.js
var TextArea_rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};












const TextArea = /*#__PURE__*/ (0,external_react_.forwardRef)((_a, ref)=>{
    var { prefixCls: customizePrefixCls, bordered = true, size: customizeSize, disabled: customDisabled, status: customStatus, allowClear, showCount, classNames: classes } = _a, rest = TextArea_rest(_a, [
        "prefixCls",
        "bordered",
        "size",
        "disabled",
        "status",
        "allowClear",
        "showCount",
        "classNames"
    ]);
    const { getPrefixCls, direction } = external_react_.useContext(context/* ConfigContext */.E_);
    // ===================== Size =====================
    const mergedSize = (0,hooks_useSize/* default */.Z)(customizeSize);
    // ===================== Disabled =====================
    const disabled = external_react_.useContext(config_provider_DisabledContext/* default */.Z);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    // ===================== Status =====================
    const { status: contextStatus, hasFeedback, feedbackIcon } = external_react_.useContext(form_context/* FormItemInputContext */.aM);
    const mergedStatus = statusUtils_getMergedStatus(contextStatus, customStatus);
    // ===================== Ref =====================
    const innerRef = external_react_.useRef(null);
    external_react_.useImperativeHandle(ref, ()=>{
        var _a;
        return {
            resizableTextArea: (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea,
            focus: (option)=>{
                var _a, _b;
                triggerFocus((_b = (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
            },
            blur: ()=>{
                var _a;
                return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.blur();
            }
        };
    });
    const prefixCls = getPrefixCls("input", customizePrefixCls);
    // Allow clear
    let mergedAllowClear;
    if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
        mergedAllowClear = allowClear;
    } else if (allowClear) {
        mergedAllowClear = {
            clearIcon: /*#__PURE__*/ external_react_.createElement(icons_CloseCircleFilled, null)
        };
    }
    // ===================== Style =====================
    const [wrapSSR, hashId] = input_style(prefixCls);
    return wrapSSR(/*#__PURE__*/ external_react_.createElement((external_rc_textarea_default()), Object.assign({}, rest, {
        disabled: mergedDisabled,
        allowClear: mergedAllowClear,
        classes: {
            affixWrapper: external_classnames_default()(`${prefixCls}-textarea-affix-wrapper`, {
                [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
                [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
                [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
                [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
                [`${prefixCls}-textarea-show-count`]: showCount
            }, statusUtils_getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus), hashId)
        },
        classNames: Object.assign(Object.assign({}, classes), {
            textarea: external_classnames_default()({
                [`${prefixCls}-borderless`]: !bordered,
                [`${prefixCls}-sm`]: mergedSize === "small",
                [`${prefixCls}-lg`]: mergedSize === "large"
            }, statusUtils_getStatusClassNames(prefixCls, mergedStatus), hashId, classes === null || classes === void 0 ? void 0 : classes.textarea)
        }),
        prefixCls: prefixCls,
        suffix: hasFeedback && /*#__PURE__*/ external_react_.createElement("span", {
            className: `${prefixCls}-textarea-suffix`
        }, feedbackIcon),
        showCount: showCount,
        ref: innerRef
    })));
});
/* harmony default export */ const input_TextArea = (TextArea);

// EXTERNAL MODULE: ./node_modules/antd/es/_util/reactNode.js
var reactNode = __webpack_require__(3564);
;// CONCATENATED MODULE: ./node_modules/antd/es/style/operationUnit.js
// eslint-disable-next-line import/prefer-default-export
const operationUnit = (token)=>({
        // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
        // And Typography use this to generate link style which should not do this.
        color: token.colorLink,
        textDecoration: "none",
        outline: "none",
        cursor: "pointer",
        transition: `color ${token.motionDurationSlow}`,
        "&:focus, &:hover": {
            color: token.colorLinkHover
        },
        "&:active": {
            color: token.colorLinkActive
        }
    });

// EXTERNAL MODULE: ./node_modules/@ant-design/colors/lib/index.js
var lib = __webpack_require__(4991);
;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/style/mixins.js
/*
.typography-title(@fontSize; @fontWeight; @lineHeight; @headingColor; @headingMarginBottom;) {
  margin-bottom: @headingMarginBottom;
  color: @headingColor;
  font-weight: @fontWeight;
  fontSize: @fontSize;
  line-height: @lineHeight;
}
*/ 


// eslint-disable-next-line import/prefer-default-export
const getTitleStyle = (fontSize, lineHeight, color, token)=>{
    const { titleMarginBottom, fontWeightStrong } = token;
    return {
        marginBottom: titleMarginBottom,
        color,
        fontWeight: fontWeightStrong,
        fontSize,
        lineHeight
    };
};
// eslint-disable-next-line import/prefer-default-export
const getTitleStyles = (token)=>{
    const headings = [
        1,
        2,
        3,
        4,
        5
    ];
    const styles = {};
    headings.forEach((headingLevel)=>{
        styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token[`fontSizeHeading${headingLevel}`], token[`lineHeightHeading${headingLevel}`], token.colorTextHeading, token);
    });
    return styles;
};
const getLinkStyles = (token)=>{
    const { componentCls } = token;
    return {
        "a&, a": Object.assign(Object.assign({}, operationUnit(token)), {
            textDecoration: token.linkDecoration,
            "&:active, &:hover": {
                textDecoration: token.linkHoverDecoration
            },
            [`&[disabled], &${componentCls}-disabled`]: {
                color: token.colorTextDisabled,
                cursor: "not-allowed",
                "&:active, &:hover": {
                    color: token.colorTextDisabled
                },
                "&:active": {
                    pointerEvents: "none"
                }
            }
        })
    };
};
const getResetStyles = (token)=>({
        code: {
            margin: "0 0.2em",
            paddingInline: "0.4em",
            paddingBlock: "0.2em 0.1em",
            fontSize: "85%",
            fontFamily: token.fontFamilyCode,
            background: "rgba(150, 150, 150, 0.1)",
            border: "1px solid rgba(100, 100, 100, 0.2)",
            borderRadius: 3
        },
        kbd: {
            margin: "0 0.2em",
            paddingInline: "0.4em",
            paddingBlock: "0.15em 0.1em",
            fontSize: "90%",
            fontFamily: token.fontFamilyCode,
            background: "rgba(150, 150, 150, 0.06)",
            border: "1px solid rgba(100, 100, 100, 0.2)",
            borderBottomWidth: 2,
            borderRadius: 3
        },
        mark: {
            padding: 0,
            // FIXME hardcode in v4
            backgroundColor: lib.gold[2]
        },
        "u, ins": {
            textDecoration: "underline",
            textDecorationSkipInk: "auto"
        },
        "s, del": {
            textDecoration: "line-through"
        },
        strong: {
            fontWeight: 600
        },
        // list
        "ul, ol": {
            marginInline: 0,
            marginBlock: "0 1em",
            padding: 0,
            li: {
                marginInline: "20px 0",
                marginBlock: 0,
                paddingInline: "4px 0",
                paddingBlock: 0
            }
        },
        ul: {
            listStyleType: "circle",
            ul: {
                listStyleType: "disc"
            }
        },
        ol: {
            listStyleType: "decimal"
        },
        // pre & block
        "pre, blockquote": {
            margin: "1em 0"
        },
        pre: {
            padding: "0.4em 0.6em",
            whiteSpace: "pre-wrap",
            wordWrap: "break-word",
            background: "rgba(150, 150, 150, 0.1)",
            border: "1px solid rgba(100, 100, 100, 0.2)",
            borderRadius: 3,
            fontFamily: token.fontFamilyCode,
            // Compatible for marked
            code: {
                display: "inline",
                margin: 0,
                padding: 0,
                fontSize: "inherit",
                fontFamily: "inherit",
                background: "transparent",
                border: 0
            }
        },
        blockquote: {
            paddingInline: "0.6em 0",
            paddingBlock: 0,
            borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
            opacity: 0.85
        }
    });
const getEditableStyles = (token)=>{
    const { componentCls } = token;
    const inputToken = initInputToken(token);
    const inputShift = inputToken.inputPaddingVertical + 1;
    return {
        "&-edit-content": {
            position: "relative",
            "div&": {
                insetInlineStart: -token.paddingSM,
                marginTop: -inputShift,
                marginBottom: `calc(1em - ${inputShift}px)`
            },
            [`${componentCls}-edit-content-confirm`]: {
                position: "absolute",
                insetInlineEnd: token.marginXS + 2,
                insetBlockEnd: token.marginXS,
                color: token.colorTextDescription,
                // default style
                fontWeight: "normal",
                fontSize: token.fontSize,
                fontStyle: "normal",
                pointerEvents: "none"
            },
            textarea: {
                margin: "0!important",
                // Fix Editable Textarea flash in Firefox
                MozTransition: "none",
                height: "1em"
            }
        }
    };
};
const getCopyableStyles = (token)=>({
        "&-copy-success": {
            [`
    &,
    &:hover,
    &:focus`]: {
                color: token.colorSuccess
            }
        }
    });
const getEllipsisStyles = ()=>({
        [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
            display: "inline-block",
            maxWidth: "100%"
        },
        "&-single-line": {
            whiteSpace: "nowrap"
        },
        "&-ellipsis-single-line": {
            overflow: "hidden",
            textOverflow: "ellipsis",
            // https://blog.csdn.net/iefreer/article/details/50421025
            "a&, span&": {
                verticalAlign: "bottom"
            }
        },
        "&-ellipsis-multiple-line": {
            display: "-webkit-box",
            overflow: "hidden",
            WebkitLineClamp: 3,
            WebkitBoxOrient: "vertical"
        }
    });

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/style/index.js



const genTypographyStyle = (token)=>{
    const { componentCls, titleMarginTop } = token;
    return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
            color: token.colorText,
            wordBreak: "break-word",
            lineHeight: token.lineHeight,
            [`&${componentCls}-secondary`]: {
                color: token.colorTextDescription
            },
            [`&${componentCls}-success`]: {
                color: token.colorSuccess
            },
            [`&${componentCls}-warning`]: {
                color: token.colorWarning
            },
            [`&${componentCls}-danger`]: {
                color: token.colorError,
                "a&:active, a&:focus": {
                    color: token.colorErrorActive
                },
                "a&:hover": {
                    color: token.colorErrorHover
                }
            },
            [`&${componentCls}-disabled`]: {
                color: token.colorTextDisabled,
                cursor: "not-allowed",
                userSelect: "none"
            },
            [`
        div&,
        p
      `]: {
                marginBottom: "1em"
            }
        }, getTitleStyles(token)), {
            [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
                marginTop: titleMarginTop
            },
            [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
                [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
                    marginTop: titleMarginTop
                }
            }
        }), getResetStyles(token)), getLinkStyles(token)), {
            // Operation
            [`
        ${componentCls}-expand,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: Object.assign(Object.assign({}, operationUnit(token)), {
                marginInlineStart: token.marginXXS
            })
        }), getEditableStyles(token)), getCopyableStyles(token)), getEllipsisStyles()), {
            "&-rtl": {
                direction: "rtl"
            }
        })
    };
};
// ============================== Export ==============================
/* harmony default export */ const Typography_style = ((0,genComponentStyleHook/* default */.Z)("Typography", (token)=>[
        genTypographyStyle(token)
    ], (token)=>({
        titleMarginTop: "1.2em",
        titleMarginBottom: "0.5em",
        fontWeightStrong: token.fontWeightStrong
    })));

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/Editable.js







const Editable = (_ref)=>{
    let { prefixCls, "aria-label": ariaLabel, className, style, direction, maxLength, autoSize = true, value, onSave, onCancel, onEnd, component, enterIcon = /*#__PURE__*/ external_react_.createElement(icons_EnterOutlined, null) } = _ref;
    const ref = external_react_.useRef(null);
    const inComposition = external_react_.useRef(false);
    const lastKeyCode = external_react_.useRef();
    const [current, setCurrent] = external_react_.useState(value);
    external_react_.useEffect(()=>{
        setCurrent(value);
    }, [
        value
    ]);
    external_react_.useEffect(()=>{
        if (ref.current && ref.current.resizableTextArea) {
            const { textArea } = ref.current.resizableTextArea;
            textArea.focus();
            const { length } = textArea.value;
            textArea.setSelectionRange(length, length);
        }
    }, []);
    const onChange = (_ref2)=>{
        let { target } = _ref2;
        setCurrent(target.value.replace(/[\n\r]/g, ""));
    };
    const onCompositionStart = ()=>{
        inComposition.current = true;
    };
    const onCompositionEnd = ()=>{
        inComposition.current = false;
    };
    const onKeyDown = (_ref3)=>{
        let { keyCode } = _ref3;
        // We don't record keyCode when IME is using
        if (inComposition.current) return;
        lastKeyCode.current = keyCode;
    };
    const confirmChange = ()=>{
        onSave(current.trim());
    };
    const onKeyUp = (_ref4)=>{
        let { keyCode, ctrlKey, altKey, metaKey, shiftKey } = _ref4;
        // Check if it's a real key
        if (lastKeyCode.current === keyCode && !inComposition.current && !ctrlKey && !altKey && !metaKey && !shiftKey) {
            if (keyCode === es_KeyCode.ENTER) {
                confirmChange();
                onEnd === null || onEnd === void 0 ? void 0 : onEnd();
            } else if (keyCode === es_KeyCode.ESC) {
                onCancel();
            }
        }
    };
    const onBlur = ()=>{
        confirmChange();
    };
    const textClassName = component ? `${prefixCls}-${component}` : "";
    const [wrapSSR, hashId] = Typography_style(prefixCls);
    const textAreaClassName = external_classnames_default()(prefixCls, `${prefixCls}-edit-content`, {
        [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, textClassName, hashId);
    return wrapSSR(/*#__PURE__*/ external_react_.createElement("div", {
        className: textAreaClassName,
        style: style
    }, /*#__PURE__*/ external_react_.createElement(input_TextArea, {
        ref: ref,
        maxLength: maxLength,
        value: current,
        onChange: onChange,
        onKeyDown: onKeyDown,
        onKeyUp: onKeyUp,
        onCompositionStart: onCompositionStart,
        onCompositionEnd: onCompositionEnd,
        onBlur: onBlur,
        "aria-label": ariaLabel,
        rows: 1,
        autoSize: autoSize
    }), enterIcon !== null ? (0,reactNode/* cloneElement */.Tm)(enterIcon, {
        className: `${prefixCls}-edit-content-confirm`
    }) : null));
};
/* harmony default export */ const Typography_Editable = (Editable);

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/Typography.js
var Typography_rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};






const Typography = /*#__PURE__*/ external_react_.forwardRef((_a, ref)=>{
    var { prefixCls: customizePrefixCls, component: Component = "article", className, rootClassName, setContentRef, children, direction: typographyDirection } = _a, restProps = Typography_rest(_a, [
        "prefixCls",
        "component",
        "className",
        "rootClassName",
        "setContentRef",
        "children",
        "direction"
    ]);
    const { getPrefixCls, direction: contextDirection } = external_react_.useContext(context/* ConfigContext */.E_);
    const direction = typographyDirection !== null && typographyDirection !== void 0 ? typographyDirection : contextDirection;
    let mergedRef = ref;
    if (setContentRef) {
         false ? 0 : void 0;
        mergedRef = (0,es_ref/* composeRef */.sQ)(ref, setContentRef);
    }
    const prefixCls = getPrefixCls("typography", customizePrefixCls);
    // Style
    const [wrapSSR, hashId] = Typography_style(prefixCls);
    const componentClassName = external_classnames_default()(prefixCls, {
        [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, hashId);
    return wrapSSR(/*#__PURE__*/ // @ts-expect-error: Expression produces a union type that is too complex to represent.
    external_react_.createElement(Component, Object.assign({
        className: componentClassName,
        ref: mergedRef
    }, restProps), children));
});
if (false) {}
// es default export should use const instead of let
/* harmony default export */ const Typography_Typography = (Typography);

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/hooks/useMergedConfig.js

function useMergedConfig(propConfig, templateConfig) {
    return external_react_.useMemo(()=>{
        const support = !!propConfig;
        return [
            support,
            Object.assign(Object.assign({}, templateConfig), support && typeof propConfig === "object" ? propConfig : null)
        ];
    }, [
        propConfig
    ]);
}

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/hooks/useUpdatedEffect.js

/** Similar with `useEffect` but only trigger after mounted */ const useUpdatedEffect = (callback, conditions)=>{
    const mountRef = external_react_.useRef(false);
    external_react_.useEffect(()=>{
        if (mountRef.current) {
            callback();
        } else {
            mountRef.current = true;
        }
    }, conditions);
};
/* harmony default export */ const hooks_useUpdatedEffect = (useUpdatedEffect);

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/Base/Ellipsis.js



function cuttable(node) {
    const type = typeof node;
    return type === "string" || type === "number";
}
function getNodesLen(nodeList) {
    let totalLen = 0;
    nodeList.forEach((node)=>{
        if (cuttable(node)) {
            totalLen += String(node).length;
        } else {
            totalLen += 1;
        }
    });
    return totalLen;
}
function sliceNodes(nodeList, len) {
    let currLen = 0;
    const currentNodeList = [];
    for(let i = 0; i < nodeList.length; i += 1){
        // Match to return
        if (currLen === len) {
            return currentNodeList;
        }
        const node = nodeList[i];
        const canCut = cuttable(node);
        const nodeLen = canCut ? String(node).length : 1;
        const nextLen = currLen + nodeLen;
        // Exceed but current not which means we need cut this
        // This will not happen on validate ReactElement
        if (nextLen > len) {
            const restLen = len - currLen;
            currentNodeList.push(String(node).slice(0, restLen));
            return currentNodeList;
        }
        currentNodeList.push(node);
        currLen = nextLen;
    }
    return nodeList;
}
const NONE = 0;
const PREPARE = 1;
const WALKING = 2;
const DONE_WITH_ELLIPSIS = 3;
const DONE_WITHOUT_ELLIPSIS = 4;
const Ellipsis = (_ref)=>{
    let { enabledMeasure, children, text, width, fontSize, rows, onEllipsis } = _ref;
    const [[startLen, midLen, endLen], setCutLength] = external_react_.useState([
        0,
        0,
        0
    ]);
    const [walkingState, setWalkingState] = external_react_.useState(NONE);
    const [singleRowHeight, setSingleRowHeight] = external_react_.useState(0);
    const singleRowRef = external_react_.useRef(null);
    const midRowRef = external_react_.useRef(null);
    const nodeList = external_react_.useMemo(()=>(0,toArray/* default */.Z)(text), [
        text
    ]);
    const totalLen = external_react_.useMemo(()=>getNodesLen(nodeList), [
        nodeList
    ]);
    const mergedChildren = external_react_.useMemo(()=>{
        if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {
            return children(nodeList, false);
        }
        return children(sliceNodes(nodeList, midLen), midLen < totalLen);
    }, [
        enabledMeasure,
        walkingState,
        children,
        nodeList,
        midLen,
        totalLen
    ]);
    // ======================== Walk ========================
    (0,useLayoutEffect/* default */.Z)(()=>{
        if (enabledMeasure && width && fontSize && totalLen) {
            setWalkingState(PREPARE);
            setCutLength([
                0,
                Math.ceil(totalLen / 2),
                totalLen
            ]);
        }
    }, [
        enabledMeasure,
        width,
        fontSize,
        text,
        totalLen,
        rows
    ]);
    (0,useLayoutEffect/* default */.Z)(()=>{
        var _a;
        if (walkingState === PREPARE) {
            setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);
        }
    }, [
        walkingState
    ]);
    (0,useLayoutEffect/* default */.Z)(()=>{
        var _a, _b;
        if (singleRowHeight) {
            if (walkingState === PREPARE) {
                // Ignore if position is enough
                const midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
                const maxHeight = rows * singleRowHeight;
                if (midHeight <= maxHeight) {
                    setWalkingState(DONE_WITHOUT_ELLIPSIS);
                    onEllipsis(false);
                } else {
                    setWalkingState(WALKING);
                }
            } else if (walkingState === WALKING) {
                if (startLen !== endLen) {
                    const midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;
                    const maxHeight = rows * singleRowHeight;
                    let nextStartLen = startLen;
                    let nextEndLen = endLen;
                    // We reach the last round
                    if (startLen === endLen - 1) {
                        nextEndLen = startLen;
                    } else if (midHeight <= maxHeight) {
                        nextStartLen = midLen;
                    } else {
                        nextEndLen = midLen;
                    }
                    const nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);
                    setCutLength([
                        nextStartLen,
                        nextMidLen,
                        nextEndLen
                    ]);
                } else {
                    setWalkingState(DONE_WITH_ELLIPSIS);
                    onEllipsis(true);
                }
            }
        }
    }, [
        walkingState,
        startLen,
        endLen,
        rows,
        singleRowHeight
    ]);
    // ======================= Render =======================
    const measureStyle = {
        width,
        whiteSpace: "normal",
        margin: 0,
        padding: 0
    };
    const renderMeasure = (content, ref, style)=>/*#__PURE__*/ external_react_.createElement("span", {
            "aria-hidden": true,
            ref: ref,
            style: Object.assign({
                position: "fixed",
                display: "block",
                left: 0,
                top: 0,
                zIndex: -9999,
                visibility: "hidden",
                pointerEvents: "none",
                fontSize: Math.floor(fontSize / 2) * 2
            }, style)
        }, content);
    const renderMeasureSlice = (len, ref)=>{
        const sliceNodeList = sliceNodes(nodeList, len);
        return renderMeasure(children(sliceNodeList, true), ref, measureStyle);
    };
    return /*#__PURE__*/ external_react_.createElement(external_react_.Fragment, null, mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS && /*#__PURE__*/ external_react_.createElement(external_react_.Fragment, null, renderMeasure("lg", singleRowRef, {
        wordBreak: "keep-all",
        whiteSpace: "nowrap"
    }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)));
};
if (false) {}
/* harmony default export */ const Base_Ellipsis = (Ellipsis);

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/Base/EllipsisTooltip.js


const EllipsisTooltip = (_ref)=>{
    let { enabledEllipsis, isEllipsis, children, tooltipProps } = _ref;
    if (!(tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.title) || !enabledEllipsis) {
        return children;
    }
    return /*#__PURE__*/ external_react_.createElement(es_tooltip/* default */.Z, Object.assign({
        open: isEllipsis ? undefined : false
    }, tooltipProps), children);
};
if (false) {}
/* harmony default export */ const Base_EllipsisTooltip = (EllipsisTooltip);

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/Base/index.js
var Base_rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};























function wrapperDecorations(_ref, content) {
    let { mark, code, underline, delete: del, strong, keyboard, italic } = _ref;
    let currentContent = content;
    function wrap(tag, needed) {
        if (!needed) {
            return;
        }
        currentContent = /*#__PURE__*/ external_react_.createElement(tag, {}, currentContent);
    }
    wrap("strong", strong);
    wrap("u", underline);
    wrap("del", del);
    wrap("code", code);
    wrap("mark", mark);
    wrap("kbd", keyboard);
    wrap("i", italic);
    return currentContent;
}
function getNode(dom, defaultNode, needDom) {
    if (dom === true || dom === undefined) {
        return defaultNode;
    }
    return dom || needDom && defaultNode;
}
function toList(val) {
    if (val === false) {
        return [
            false,
            false
        ];
    }
    return Array.isArray(val) ? val : [
        val
    ];
}
const ELLIPSIS_STR = "...";
const Base = /*#__PURE__*/ external_react_.forwardRef((props, ref)=>{
    var _a, _b, _c;
    const { prefixCls: customizePrefixCls, className, style, type, disabled, children, ellipsis, editable, copyable, component, title } = props, restProps = Base_rest(props, [
        "prefixCls",
        "className",
        "style",
        "type",
        "disabled",
        "children",
        "ellipsis",
        "editable",
        "copyable",
        "component",
        "title"
    ]);
    const { getPrefixCls, direction } = external_react_.useContext(context/* ConfigContext */.E_);
    const [textLocale] = locale_useLocale("Text");
    const typographyRef = external_react_.useRef(null);
    const editIconRef = external_react_.useRef(null);
    // ============================ MISC ============================
    const prefixCls = getPrefixCls("typography", customizePrefixCls);
    const textProps = (0,omit/* default */.Z)(restProps, [
        "mark",
        "code",
        "delete",
        "underline",
        "strong",
        "keyboard",
        "italic"
    ]);
    // ========================== Editable ==========================
    const [enableEdit, editConfig] = useMergedConfig(editable);
    const [editing, setEditing] = (0,useMergedState/* default */.Z)(false, {
        value: editConfig.editing
    });
    const { triggerType = [
        "icon"
    ] } = editConfig;
    const triggerEdit = (edit)=>{
        var _a;
        if (edit) {
            (_a = editConfig.onStart) === null || _a === void 0 ? void 0 : _a.call(editConfig);
        }
        setEditing(edit);
    };
    // Focus edit icon when back
    hooks_useUpdatedEffect(()=>{
        var _a;
        if (!editing) {
            (_a = editIconRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }, [
        editing
    ]);
    const onEditClick = (e)=>{
        e === null || e === void 0 ? void 0 : e.preventDefault();
        triggerEdit(true);
    };
    const onEditChange = (value)=>{
        var _a;
        (_a = editConfig.onChange) === null || _a === void 0 ? void 0 : _a.call(editConfig, value);
        triggerEdit(false);
    };
    const onEditCancel = ()=>{
        var _a;
        (_a = editConfig.onCancel) === null || _a === void 0 ? void 0 : _a.call(editConfig);
        triggerEdit(false);
    };
    // ========================== Copyable ==========================
    const [enableCopy, copyConfig] = useMergedConfig(copyable);
    const [copied, setCopied] = external_react_.useState(false);
    const copyIdRef = external_react_.useRef(null);
    const copyOptions = {};
    if (copyConfig.format) {
        copyOptions.format = copyConfig.format;
    }
    const cleanCopyId = ()=>{
        if (copyIdRef.current) {
            clearTimeout(copyIdRef.current);
        }
    };
    const onCopyClick = (e)=>{
        var _a;
        e === null || e === void 0 ? void 0 : e.preventDefault();
        e === null || e === void 0 ? void 0 : e.stopPropagation();
        external_copy_to_clipboard_default()(copyConfig.text || String(children) || "", copyOptions);
        setCopied(true);
        // Trigger tips update
        cleanCopyId();
        copyIdRef.current = setTimeout(()=>{
            setCopied(false);
        }, 3000);
        (_a = copyConfig.onCopy) === null || _a === void 0 ? void 0 : _a.call(copyConfig, e);
    };
    external_react_.useEffect(()=>cleanCopyId, []);
    // ========================== Ellipsis ==========================
    const [isLineClampSupport, setIsLineClampSupport] = external_react_.useState(false);
    const [isTextOverflowSupport, setIsTextOverflowSupport] = external_react_.useState(false);
    const [expanded, setExpanded] = external_react_.useState(false);
    const [isJsEllipsis, setIsJsEllipsis] = external_react_.useState(false);
    const [isNativeEllipsis, setIsNativeEllipsis] = external_react_.useState(false);
    const [isNativeVisible, setIsNativeVisible] = external_react_.useState(true);
    const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
        expandable: false
    });
    const mergedEnableEllipsis = enableEllipsis && !expanded;
    // Shared prop to reduce bundle size
    const { rows = 1 } = ellipsisConfig;
    const needMeasureEllipsis = external_react_.useMemo(()=>// Disable ellipsis
        !mergedEnableEllipsis || // Provide suffix
        ellipsisConfig.suffix !== undefined || ellipsisConfig.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
        ellipsisConfig.expandable || enableEdit || enableCopy, [
        mergedEnableEllipsis,
        ellipsisConfig,
        enableEdit,
        enableCopy
    ]);
    (0,useLayoutEffect/* default */.Z)(()=>{
        if (enableEllipsis && !needMeasureEllipsis) {
            setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
            setIsTextOverflowSupport(isStyleSupport("textOverflow"));
        }
    }, [
        needMeasureEllipsis,
        enableEllipsis
    ]);
    const cssEllipsis = external_react_.useMemo(()=>{
        if (needMeasureEllipsis) {
            return false;
        }
        if (rows === 1) {
            return isTextOverflowSupport;
        }
        return isLineClampSupport;
    }, [
        needMeasureEllipsis,
        isTextOverflowSupport,
        isLineClampSupport
    ]);
    const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
    const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
    const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
    // >>>>> Expand
    const onExpandClick = (e)=>{
        var _a;
        setExpanded(true);
        (_a = ellipsisConfig.onExpand) === null || _a === void 0 ? void 0 : _a.call(ellipsisConfig, e);
    };
    const [ellipsisWidth, setEllipsisWidth] = external_react_.useState(0);
    const [ellipsisFontSize, setEllipsisFontSize] = external_react_.useState(0);
    const onResize = (_ref2, element)=>{
        let { offsetWidth } = _ref2;
        var _a;
        setEllipsisWidth(offsetWidth);
        setEllipsisFontSize(parseInt((_a = window.getComputedStyle) === null || _a === void 0 ? void 0 : _a.call(window, element).fontSize, 10) || 0);
    };
    // >>>>> JS Ellipsis
    const onJsEllipsis = (jsEllipsis)=>{
        var _a;
        setIsJsEllipsis(jsEllipsis);
        // Trigger if changed
        if (isJsEllipsis !== jsEllipsis) {
            (_a = ellipsisConfig.onEllipsis) === null || _a === void 0 ? void 0 : _a.call(ellipsisConfig, jsEllipsis);
        }
    };
    // >>>>> Native ellipsis
    external_react_.useEffect(()=>{
        const textEle = typographyRef.current;
        if (enableEllipsis && cssEllipsis && textEle) {
            const currentEllipsis = cssLineClamp ? textEle.offsetHeight < textEle.scrollHeight : textEle.offsetWidth < textEle.scrollWidth;
            if (isNativeEllipsis !== currentEllipsis) {
                setIsNativeEllipsis(currentEllipsis);
            }
        }
    }, [
        enableEllipsis,
        cssEllipsis,
        children,
        cssLineClamp,
        isNativeVisible
    ]);
    // https://github.com/ant-design/ant-design/issues/36786
    // Use IntersectionObserver to check if element is invisible
    external_react_.useEffect(()=>{
        const textEle = typographyRef.current;
        if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) {
            return;
        }
        /* eslint-disable-next-line compat/compat */ const observer = new IntersectionObserver(()=>{
            setIsNativeVisible(!!textEle.offsetParent);
        });
        observer.observe(textEle);
        return ()=>{
            observer.disconnect();
        };
    }, [
        cssEllipsis,
        mergedEnableEllipsis
    ]);
    // ========================== Tooltip ===========================
    let tooltipProps = {};
    if (ellipsisConfig.tooltip === true) {
        tooltipProps = {
            title: (_a = editConfig.text) !== null && _a !== void 0 ? _a : children
        };
    } else if (/*#__PURE__*/ external_react_.isValidElement(ellipsisConfig.tooltip)) {
        tooltipProps = {
            title: ellipsisConfig.tooltip
        };
    } else if (typeof ellipsisConfig.tooltip === "object") {
        tooltipProps = Object.assign({
            title: (_b = editConfig.text) !== null && _b !== void 0 ? _b : children
        }, ellipsisConfig.tooltip);
    } else {
        tooltipProps = {
            title: ellipsisConfig.tooltip
        };
    }
    const topAriaLabel = external_react_.useMemo(()=>{
        const isValid = (val)=>[
                "string",
                "number"
            ].includes(typeof val);
        if (!enableEllipsis || cssEllipsis) {
            return undefined;
        }
        if (isValid(editConfig.text)) {
            return editConfig.text;
        }
        if (isValid(children)) {
            return children;
        }
        if (isValid(title)) {
            return title;
        }
        if (isValid(tooltipProps.title)) {
            return tooltipProps.title;
        }
        return undefined;
    }, [
        enableEllipsis,
        cssEllipsis,
        title,
        tooltipProps.title,
        isMergedEllipsis
    ]);
    // =========================== Render ===========================
    // >>>>>>>>>>> Editing input
    if (editing) {
        return /*#__PURE__*/ external_react_.createElement(Typography_Editable, {
            value: (_c = editConfig.text) !== null && _c !== void 0 ? _c : typeof children === "string" ? children : "",
            onSave: onEditChange,
            onCancel: onEditCancel,
            onEnd: editConfig.onEnd,
            prefixCls: prefixCls,
            className: className,
            style: style,
            direction: direction,
            component: component,
            maxLength: editConfig.maxLength,
            autoSize: editConfig.autoSize,
            enterIcon: editConfig.enterIcon
        });
    }
    // >>>>>>>>>>> Typography
    // Expand
    const renderExpand = ()=>{
        const { expandable, symbol } = ellipsisConfig;
        if (!expandable) return null;
        let expandContent;
        if (symbol) {
            expandContent = symbol;
        } else {
            expandContent = textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand;
        }
        return /*#__PURE__*/ external_react_.createElement("a", {
            key: "expand",
            className: `${prefixCls}-expand`,
            onClick: onExpandClick,
            "aria-label": textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand
        }, expandContent);
    };
    // Edit
    const renderEdit = ()=>{
        if (!enableEdit) return;
        const { icon, tooltip } = editConfig;
        const editTitle = (0,toArray/* default */.Z)(tooltip)[0] || (textLocale === null || textLocale === void 0 ? void 0 : textLocale.edit);
        const ariaLabel = typeof editTitle === "string" ? editTitle : "";
        return triggerType.includes("icon") ? /*#__PURE__*/ external_react_.createElement(es_tooltip/* default */.Z, {
            key: "edit",
            title: tooltip === false ? "" : editTitle
        }, /*#__PURE__*/ external_react_.createElement(transButton, {
            ref: editIconRef,
            className: `${prefixCls}-edit`,
            onClick: onEditClick,
            "aria-label": ariaLabel
        }, icon || /*#__PURE__*/ external_react_.createElement(icons_EditOutlined, {
            role: "button"
        }))) : null;
    };
    // Copy
    const renderCopy = ()=>{
        if (!enableCopy) return;
        const { tooltips, icon } = copyConfig;
        const tooltipNodes = toList(tooltips);
        const iconNodes = toList(icon);
        const copyTitle = copied ? getNode(tooltipNodes[1], textLocale === null || textLocale === void 0 ? void 0 : textLocale.copied) : getNode(tooltipNodes[0], textLocale === null || textLocale === void 0 ? void 0 : textLocale.copy);
        const systemStr = copied ? textLocale === null || textLocale === void 0 ? void 0 : textLocale.copied : textLocale === null || textLocale === void 0 ? void 0 : textLocale.copy;
        const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
        return /*#__PURE__*/ external_react_.createElement(es_tooltip/* default */.Z, {
            key: "copy",
            title: copyTitle
        }, /*#__PURE__*/ external_react_.createElement(transButton, {
            className: external_classnames_default()(`${prefixCls}-copy`, copied && `${prefixCls}-copy-success`),
            onClick: onCopyClick,
            "aria-label": ariaLabel
        }, copied ? getNode(iconNodes[1], /*#__PURE__*/ external_react_.createElement(icons_CheckOutlined, null), true) : getNode(iconNodes[0], /*#__PURE__*/ external_react_.createElement(icons_CopyOutlined, null), true)));
    };
    const renderOperations = (renderExpanded)=>[
            renderExpanded && renderExpand(),
            renderEdit(),
            renderCopy()
        ];
    const renderEllipsis = (needEllipsis)=>[
            needEllipsis && /*#__PURE__*/ external_react_.createElement("span", {
                "aria-hidden": true,
                key: "ellipsis"
            }, ELLIPSIS_STR),
            ellipsisConfig.suffix,
            renderOperations(needEllipsis)
        ];
    return /*#__PURE__*/ external_react_.createElement((external_rc_resize_observer_default()), {
        onResize: onResize,
        disabled: !mergedEnableEllipsis || cssEllipsis
    }, (resizeRef)=>/*#__PURE__*/ external_react_.createElement(Base_EllipsisTooltip, {
            tooltipProps: tooltipProps,
            enabledEllipsis: mergedEnableEllipsis,
            isEllipsis: isMergedEllipsis
        }, /*#__PURE__*/ external_react_.createElement(Typography_Typography, Object.assign({
            className: external_classnames_default()({
                [`${prefixCls}-${type}`]: type,
                [`${prefixCls}-disabled`]: disabled,
                [`${prefixCls}-ellipsis`]: enableEllipsis,
                [`${prefixCls}-single-line`]: mergedEnableEllipsis && rows === 1,
                [`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
                [`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
            }, className),
            prefixCls: customizePrefixCls,
            style: Object.assign(Object.assign({}, style), {
                WebkitLineClamp: cssLineClamp ? rows : undefined
            }),
            component: component,
            ref: (0,es_ref/* composeRef */.sQ)(resizeRef, typographyRef, ref),
            direction: direction,
            onClick: triggerType.includes("text") ? onEditClick : undefined,
            "aria-label": topAriaLabel === null || topAriaLabel === void 0 ? void 0 : topAriaLabel.toString(),
            title: title
        }, textProps), /*#__PURE__*/ external_react_.createElement(Base_Ellipsis, {
            enabledMeasure: mergedEnableEllipsis && !cssEllipsis,
            text: children,
            rows: rows,
            width: ellipsisWidth,
            fontSize: ellipsisFontSize,
            onEllipsis: onJsEllipsis
        }, (node, needEllipsis)=>{
            let renderNode = node;
            if (node.length && needEllipsis && topAriaLabel) {
                renderNode = /*#__PURE__*/ external_react_.createElement("span", {
                    key: "show-content",
                    "aria-hidden": true
                }, renderNode);
            }
            const wrappedContext = wrapperDecorations(props, /*#__PURE__*/ external_react_.createElement(external_react_.Fragment, null, renderNode, renderEllipsis(needEllipsis)));
            return wrappedContext;
        }))));
});
/* harmony default export */ const Typography_Base = (Base);

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/Link.js
var Link_rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};



const Link = /*#__PURE__*/ external_react_.forwardRef((_a, ref)=>{
    var { ellipsis, rel } = _a, restProps = Link_rest(_a, [
        "ellipsis",
        "rel"
    ]);
     false ? 0 : void 0;
    const mergedProps = Object.assign(Object.assign({}, restProps), {
        rel: rel === undefined && restProps.target === "_blank" ? "noopener noreferrer" : rel
    });
    // @ts-expect-error: https://github.com/ant-design/ant-design/issues/26622
    delete mergedProps.navigate;
    return /*#__PURE__*/ external_react_.createElement(Typography_Base, Object.assign({}, mergedProps, {
        ref: ref,
        ellipsis: !!ellipsis,
        component: "a"
    }));
});
/* harmony default export */ const Typography_Link = (Link);

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/Paragraph.js


const Paragraph = /*#__PURE__*/ external_react_.forwardRef((props, ref)=>/*#__PURE__*/ external_react_.createElement(Typography_Base, Object.assign({
        ref: ref
    }, props, {
        component: "div"
    })));
/* harmony default export */ const Typography_Paragraph = (Paragraph);

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/Text.js
var Text_rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};




const Text = (_a, ref)=>{
    var { ellipsis } = _a, restProps = Text_rest(_a, [
        "ellipsis"
    ]);
    const mergedEllipsis = external_react_.useMemo(()=>{
        if (ellipsis && typeof ellipsis === "object") {
            return (0,omit/* default */.Z)(ellipsis, [
                "expandable",
                "rows"
            ]);
        }
        return ellipsis;
    }, [
        ellipsis
    ]);
     false ? 0 : void 0;
    return /*#__PURE__*/ external_react_.createElement(Typography_Base, Object.assign({
        ref: ref
    }, restProps, {
        ellipsis: mergedEllipsis,
        component: "span"
    }));
};
/* harmony default export */ const Typography_Text = (/*#__PURE__*/external_react_.forwardRef(Text));

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/Title.js
var Title_rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};



const TITLE_ELE_LIST = [
    1,
    2,
    3,
    4,
    5
];
const Title = /*#__PURE__*/ external_react_.forwardRef((props, ref)=>{
    const { level = 1 } = props, restProps = Title_rest(props, [
        "level"
    ]);
    let component;
    if (TITLE_ELE_LIST.includes(level)) {
        component = `h${level}`;
    } else {
         false ? 0 : void 0;
        component = "h1";
    }
    return /*#__PURE__*/ external_react_.createElement(Typography_Base, Object.assign({
        ref: ref
    }, restProps, {
        component: component
    }));
});
/* harmony default export */ const Typography_Title = (Title);

;// CONCATENATED MODULE: ./node_modules/antd/es/Typography/index.js





const es_Typography_Typography = Typography_Typography;
es_Typography_Typography.Text = Typography_Text;
es_Typography_Typography.Link = Typography_Link;
es_Typography_Typography.Title = Typography_Title;
es_Typography_Typography.Paragraph = Typography_Paragraph;
/* harmony default export */ const es_Typography = (es_Typography_Typography);


/***/ })

};
;